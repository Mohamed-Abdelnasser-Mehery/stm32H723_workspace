\hypertarget{group__sys__sem}{}\doxysection{Semaphores}
\label{group__sys__sem}\index{Semaphores@{Semaphores}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} \mbox{\hyperlink{group__sys__sem_gaf99da9e34a71855285c535183133dfde}{sys\+\_\+sem\+\_\+new}} (sys\+\_\+sem\+\_\+t $\ast$sem, u8\+\_\+t count)
\item 
void \mbox{\hyperlink{group__sys__sem_gaaf800273061fcc3f8200fd4e1b9ca875}{sys\+\_\+sem\+\_\+signal}} (sys\+\_\+sem\+\_\+t $\ast$sem)
\item 
u32\+\_\+t \mbox{\hyperlink{group__sys__sem_ga8d364c5037778acb21c3df675db81b4f}{sys\+\_\+arch\+\_\+sem\+\_\+wait}} (sys\+\_\+sem\+\_\+t $\ast$sem, u32\+\_\+t timeout)
\item 
void \mbox{\hyperlink{group__sys__sem_ga83b781f96c30e915c752065a757da283}{sys\+\_\+sem\+\_\+free}} (sys\+\_\+sem\+\_\+t $\ast$sem)
\item 
int \mbox{\hyperlink{group__sys__sem_ga09a6c052ddaf799139efc56adfa087e4}{sys\+\_\+sem\+\_\+valid}} (sys\+\_\+sem\+\_\+t $\ast$sem)
\item 
void \mbox{\hyperlink{group__sys__sem_ga42a2ab32afbf41a4146a9d135224ef33}{sys\+\_\+sem\+\_\+set\+\_\+invalid}} (sys\+\_\+sem\+\_\+t $\ast$sem)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Semaphores can be either counting or binary -\/ lw\+IP works with both kinds. Semaphores are represented by the type \char`\"{}sys\+\_\+sem\+\_\+t\char`\"{} which is typedef\textquotesingle{}d in the \mbox{\hyperlink{sys__arch_8h_source}{sys\+\_\+arch.\+h}} file. Mailboxes are equivalently represented by the type \char`\"{}sys\+\_\+mbox\+\_\+t\char`\"{}. Mutexes are represented by the type \char`\"{}sys\+\_\+mutex\+\_\+t\char`\"{}. lw\+IP does not place any restrictions on how these types are represented internally. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__sys__sem_ga8d364c5037778acb21c3df675db81b4f}\label{group__sys__sem_ga8d364c5037778acb21c3df675db81b4f}} 
\index{Semaphores@{Semaphores}!sys\_arch\_sem\_wait@{sys\_arch\_sem\_wait}}
\index{sys\_arch\_sem\_wait@{sys\_arch\_sem\_wait}!Semaphores@{Semaphores}}
\doxysubsubsection{\texorpdfstring{sys\_arch\_sem\_wait()}{sys\_arch\_sem\_wait()}}
{\footnotesize\ttfamily u32\+\_\+t sys\+\_\+arch\+\_\+sem\+\_\+wait (\begin{DoxyParamCaption}\item[{sys\+\_\+sem\+\_\+t $\ast$}]{sem,  }\item[{u32\+\_\+t}]{timeout }\end{DoxyParamCaption})}

Blocks the thread while waiting for the semaphore to be signaled. If the \char`\"{}timeout\char`\"{} argument is non-\/zero, the thread should only be blocked for the specified time (measured in milliseconds). If the \char`\"{}timeout\char`\"{} argument is zero, the thread should be blocked until the semaphore is signalled.

The return value is SYS\+\_\+\+ARCH\+\_\+\+TIMEOUT if the semaphore wasn\textquotesingle{}t signaled within the specified time or any other value if it was signaled (with or without waiting). Notice that lw\+IP implements a function with a similar name, \mbox{\hyperlink{sys_8h_a84e7e4bc00255aee84e6e7289a985703}{sys\+\_\+sem\+\_\+wait()}}, that uses the \mbox{\hyperlink{group__sys__sem_ga8d364c5037778acb21c3df675db81b4f}{sys\+\_\+arch\+\_\+sem\+\_\+wait()}} function.


\begin{DoxyParams}{Parameters}
{\em sem} & the semaphore to wait for \\
\hline
{\em timeout} & timeout in milliseconds to wait (0 = wait forever) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
SYS\+\_\+\+ARCH\+\_\+\+TIMEOUT on timeout, any other value on success 
\end{DoxyReturn}
\mbox{\Hypertarget{group__sys__sem_ga83b781f96c30e915c752065a757da283}\label{group__sys__sem_ga83b781f96c30e915c752065a757da283}} 
\index{Semaphores@{Semaphores}!sys\_sem\_free@{sys\_sem\_free}}
\index{sys\_sem\_free@{sys\_sem\_free}!Semaphores@{Semaphores}}
\doxysubsubsection{\texorpdfstring{sys\_sem\_free()}{sys\_sem\_free()}}
{\footnotesize\ttfamily void sys\+\_\+sem\+\_\+free (\begin{DoxyParamCaption}\item[{sys\+\_\+sem\+\_\+t $\ast$}]{sem }\end{DoxyParamCaption})}

Deallocates a semaphore. 
\begin{DoxyParams}{Parameters}
{\em sem} & semaphore to delete \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__sys__sem_gaf99da9e34a71855285c535183133dfde}\label{group__sys__sem_gaf99da9e34a71855285c535183133dfde}} 
\index{Semaphores@{Semaphores}!sys\_sem\_new@{sys\_sem\_new}}
\index{sys\_sem\_new@{sys\_sem\_new}!Semaphores@{Semaphores}}
\doxysubsubsection{\texorpdfstring{sys\_sem\_new()}{sys\_sem\_new()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} sys\+\_\+sem\+\_\+new (\begin{DoxyParamCaption}\item[{sys\+\_\+sem\+\_\+t $\ast$}]{sem,  }\item[{u8\+\_\+t}]{count }\end{DoxyParamCaption})}

Create a new semaphore Creates a new semaphore. The semaphore is allocated to the memory that \textquotesingle{}sem\textquotesingle{} points to (which can be both a pointer or the actual OS structure). The \char`\"{}count\char`\"{} argument specifies the initial state of the semaphore (which is either 0 or 1). If the semaphore has been created, ERR\+\_\+\+OK should be returned. Returning any other error will provide a hint what went wrong, but except for assertions, no real error handling is implemented.


\begin{DoxyParams}{Parameters}
{\em sem} & pointer to the semaphore to create \\
\hline
{\em count} & initial count of the semaphore \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ERR\+\_\+\+OK if successful, another err\+\_\+t otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{group__sys__sem_ga42a2ab32afbf41a4146a9d135224ef33}\label{group__sys__sem_ga42a2ab32afbf41a4146a9d135224ef33}} 
\index{Semaphores@{Semaphores}!sys\_sem\_set\_invalid@{sys\_sem\_set\_invalid}}
\index{sys\_sem\_set\_invalid@{sys\_sem\_set\_invalid}!Semaphores@{Semaphores}}
\doxysubsubsection{\texorpdfstring{sys\_sem\_set\_invalid()}{sys\_sem\_set\_invalid()}}
{\footnotesize\ttfamily void sys\+\_\+sem\+\_\+set\+\_\+invalid (\begin{DoxyParamCaption}\item[{sys\+\_\+sem\+\_\+t $\ast$}]{sem }\end{DoxyParamCaption})}

Invalidate a semaphore so that \mbox{\hyperlink{group__sys__sem_ga09a6c052ddaf799139efc56adfa087e4}{sys\+\_\+sem\+\_\+valid()}} returns 0. ATTENTION\+: This does NOT mean that the semaphore shall be deallocated\+: \mbox{\hyperlink{group__sys__sem_ga83b781f96c30e915c752065a757da283}{sys\+\_\+sem\+\_\+free()}} is always called before calling this function! This may also be a define, in which case the function is not prototyped. \mbox{\Hypertarget{group__sys__sem_gaaf800273061fcc3f8200fd4e1b9ca875}\label{group__sys__sem_gaaf800273061fcc3f8200fd4e1b9ca875}} 
\index{Semaphores@{Semaphores}!sys\_sem\_signal@{sys\_sem\_signal}}
\index{sys\_sem\_signal@{sys\_sem\_signal}!Semaphores@{Semaphores}}
\doxysubsubsection{\texorpdfstring{sys\_sem\_signal()}{sys\_sem\_signal()}}
{\footnotesize\ttfamily void sys\+\_\+sem\+\_\+signal (\begin{DoxyParamCaption}\item[{sys\+\_\+sem\+\_\+t $\ast$}]{sem }\end{DoxyParamCaption})}

Signals a semaphore 
\begin{DoxyParams}{Parameters}
{\em sem} & the semaphore to signal \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__sys__sem_ga09a6c052ddaf799139efc56adfa087e4}\label{group__sys__sem_ga09a6c052ddaf799139efc56adfa087e4}} 
\index{Semaphores@{Semaphores}!sys\_sem\_valid@{sys\_sem\_valid}}
\index{sys\_sem\_valid@{sys\_sem\_valid}!Semaphores@{Semaphores}}
\doxysubsubsection{\texorpdfstring{sys\_sem\_valid()}{sys\_sem\_valid()}}
{\footnotesize\ttfamily int sys\+\_\+sem\+\_\+valid (\begin{DoxyParamCaption}\item[{sys\+\_\+sem\+\_\+t $\ast$}]{sem }\end{DoxyParamCaption})}

Returns 1 if the semaphore is valid, 0 if it is not valid. When using pointers, a simple way is to check the pointer for != NULL. When directly using OS structures, implementing this may be more complex. This may also be a define, in which case the function is not prototyped. 