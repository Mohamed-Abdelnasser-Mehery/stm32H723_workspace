\hypertarget{mem_8h}{}\doxysection{C\+:/\+Users/\+User\+\_\+4/\+STM32\+Cube\+IDE/workspace\+\_\+1.10.1/ethernet\+\_\+\+UDB/\+Middlewares/\+Third\+\_\+\+Party/\+Lw\+IP/src/include/lwip/mem.h File Reference}
\label{mem_8h}\index{C:/Users/User\_4/STM32CubeIDE/workspace\_1.10.1/ethernet\_UDB/Middlewares/Third\_Party/LwIP/src/include/lwip/mem.h@{C:/Users/User\_4/STM32CubeIDE/workspace\_1.10.1/ethernet\_UDB/Middlewares/Third\_Party/LwIP/src/include/lwip/mem.h}}
{\ttfamily \#include \char`\"{}lwip/opt.\+h\char`\"{}}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{mem_8h_a2cf923436027f37ef24b3abd898120a7}\label{mem_8h_a2cf923436027f37ef24b3abd898120a7}} 
\#define {\bfseries MEM\+\_\+\+SIZE\+\_\+F}~U16\+\_\+F
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{mem_8h_a49bff6e5dd4cb95fe6dc0670962bbf54}\label{mem_8h_a49bff6e5dd4cb95fe6dc0670962bbf54}} 
typedef u16\+\_\+t {\bfseries mem\+\_\+size\+\_\+t}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{mem_8h_a44a136e3b70c36abb6f8dc060c778113}{mem\+\_\+init}} (void)
\item 
void $\ast$ \mbox{\hyperlink{mem_8h_a2ba2d1e6fc284b1850eedb673eba96b0}{mem\+\_\+trim}} (void $\ast$mem, mem\+\_\+size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{mem_8h_a52ce222aebe4b7dce7f25cd536b6e650}{mem\+\_\+malloc}} (mem\+\_\+size\+\_\+t size)
\item 
void $\ast$ \mbox{\hyperlink{mem_8h_a06b2fb3a6f6a6c56a84f769e0bd4c8e7}{mem\+\_\+calloc}} (mem\+\_\+size\+\_\+t count, mem\+\_\+size\+\_\+t size)
\item 
void \mbox{\hyperlink{mem_8h_a2fd7aa1adf6e394d3be7c7734e7df41a}{mem\+\_\+free}} (void $\ast$mem)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Heap API 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{mem_8h_a06b2fb3a6f6a6c56a84f769e0bd4c8e7}\label{mem_8h_a06b2fb3a6f6a6c56a84f769e0bd4c8e7}} 
\index{mem.h@{mem.h}!mem\_calloc@{mem\_calloc}}
\index{mem\_calloc@{mem\_calloc}!mem.h@{mem.h}}
\doxysubsubsection{\texorpdfstring{mem\_calloc()}{mem\_calloc()}}
{\footnotesize\ttfamily void $\ast$ mem\+\_\+calloc (\begin{DoxyParamCaption}\item[{mem\+\_\+size\+\_\+t}]{count,  }\item[{mem\+\_\+size\+\_\+t}]{size }\end{DoxyParamCaption})}

Contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory.

The allocated memory is filled with bytes of value zero.


\begin{DoxyParams}{Parameters}
{\em count} & number of objects to allocate \\
\hline
{\em size} & size of the objects to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to allocated memory / NULL pointer if there is an error 
\end{DoxyReturn}
\mbox{\Hypertarget{mem_8h_a2fd7aa1adf6e394d3be7c7734e7df41a}\label{mem_8h_a2fd7aa1adf6e394d3be7c7734e7df41a}} 
\index{mem.h@{mem.h}!mem\_free@{mem\_free}}
\index{mem\_free@{mem\_free}!mem.h@{mem.h}}
\doxysubsubsection{\texorpdfstring{mem\_free()}{mem\_free()}}
{\footnotesize\ttfamily void mem\+\_\+free (\begin{DoxyParamCaption}\item[{void $\ast$}]{rmem }\end{DoxyParamCaption})}

Put a struct mem back on the heap


\begin{DoxyParams}{Parameters}
{\em rmem} & is the data portion of a struct mem as returned by a previous call to \mbox{\hyperlink{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}{mem\+\_\+malloc()}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{mem_8h_a44a136e3b70c36abb6f8dc060c778113}\label{mem_8h_a44a136e3b70c36abb6f8dc060c778113}} 
\index{mem.h@{mem.h}!mem\_init@{mem\_init}}
\index{mem\_init@{mem\_init}!mem.h@{mem.h}}
\doxysubsubsection{\texorpdfstring{mem\_init()}{mem\_init()}}
{\footnotesize\ttfamily void mem\+\_\+init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Zero the heap and initialize start, end and lowest-\/free \mbox{\Hypertarget{mem_8h_a52ce222aebe4b7dce7f25cd536b6e650}\label{mem_8h_a52ce222aebe4b7dce7f25cd536b6e650}} 
\index{mem.h@{mem.h}!mem\_malloc@{mem\_malloc}}
\index{mem\_malloc@{mem\_malloc}!mem.h@{mem.h}}
\doxysubsubsection{\texorpdfstring{mem\_malloc()}{mem\_malloc()}}
{\footnotesize\ttfamily void $\ast$ mem\+\_\+malloc (\begin{DoxyParamCaption}\item[{mem\+\_\+size\+\_\+t}]{size\+\_\+in }\end{DoxyParamCaption})}

Allocate a block of memory with a minimum of \textquotesingle{}size\textquotesingle{} bytes.


\begin{DoxyParams}{Parameters}
{\em size\+\_\+in} & is the minimum size of the requested block in bytes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to allocated memory or NULL if no free memory was found.
\end{DoxyReturn}
Note that the returned value will always be aligned (as defined by MEM\+\_\+\+ALIGNMENT). \mbox{\Hypertarget{mem_8h_a2ba2d1e6fc284b1850eedb673eba96b0}\label{mem_8h_a2ba2d1e6fc284b1850eedb673eba96b0}} 
\index{mem.h@{mem.h}!mem\_trim@{mem\_trim}}
\index{mem\_trim@{mem\_trim}!mem.h@{mem.h}}
\doxysubsubsection{\texorpdfstring{mem\_trim()}{mem\_trim()}}
{\footnotesize\ttfamily void $\ast$ mem\+\_\+trim (\begin{DoxyParamCaption}\item[{void $\ast$}]{rmem,  }\item[{mem\+\_\+size\+\_\+t}]{new\+\_\+size }\end{DoxyParamCaption})}

Shrink memory returned by \mbox{\hyperlink{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}{mem\+\_\+malloc()}}.


\begin{DoxyParams}{Parameters}
{\em rmem} & pointer to memory allocated by mem\+\_\+malloc the is to be shrinked \\
\hline
{\em new\+\_\+size} & required size after shrinking (needs to be smaller than or equal to the previous size) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
for compatibility reasons\+: is always == rmem, at the moment or NULL if newsize is \texorpdfstring{$>$}{>} old size, in which case rmem is NOT touched or freed! 
\end{DoxyReturn}
