\hypertarget{mem_8c}{}\doxysection{C\+:/\+Users/\+User\+\_\+4/\+STM32\+Cube\+IDE/workspace\+\_\+1.10.1/ethernet\+\_\+\+UDB/\+Middlewares/\+Third\+\_\+\+Party/\+Lw\+IP/src/core/mem.c File Reference}
\label{mem_8c}\index{C:/Users/User\_4/STM32CubeIDE/workspace\_1.10.1/ethernet\_UDB/Middlewares/Third\_Party/LwIP/src/core/mem.c@{C:/Users/User\_4/STM32CubeIDE/workspace\_1.10.1/ethernet\_UDB/Middlewares/Third\_Party/LwIP/src/core/mem.c}}
{\ttfamily \#include \char`\"{}lwip/opt.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lwip/mem.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lwip/def.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lwip/sys.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lwip/stats.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lwip/err.\+h\char`\"{}}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{mem_8c_a6e206b9300fb087168cf4afd58848583}\label{mem_8c_a6e206b9300fb087168cf4afd58848583}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+ILLEGAL\+\_\+\+FREE}(msg)~LWIP\+\_\+\+ASSERT(msg, 0)
\item 
\mbox{\Hypertarget{mem_8c_a1128d7d6387c0c99c46982cafc366732}\label{mem_8c_a1128d7d6387c0c99c46982cafc366732}} 
\#define {\bfseries MEM\+\_\+\+STATS\+\_\+\+INC\+\_\+\+LOCKED}(x)~SYS\+\_\+\+ARCH\+\_\+\+LOCKED(MEM\+\_\+\+STATS\+\_\+\+INC(x))
\item 
\mbox{\Hypertarget{mem_8c_aaf3f180eb9bce81a192e7f2a172370a0}\label{mem_8c_aaf3f180eb9bce81a192e7f2a172370a0}} 
\#define {\bfseries MEM\+\_\+\+STATS\+\_\+\+INC\+\_\+\+USED\+\_\+\+LOCKED}(x,  y)~SYS\+\_\+\+ARCH\+\_\+\+LOCKED(MEM\+\_\+\+STATS\+\_\+\+INC\+\_\+\+USED(x, y))
\item 
\mbox{\Hypertarget{mem_8c_a0c6112b8029e2a25cf7afbee7f1843e3}\label{mem_8c_a0c6112b8029e2a25cf7afbee7f1843e3}} 
\#define {\bfseries MEM\+\_\+\+STATS\+\_\+\+DEC\+\_\+\+USED\+\_\+\+LOCKED}(x,  y)~SYS\+\_\+\+ARCH\+\_\+\+LOCKED(MEM\+\_\+\+STATS\+\_\+\+DEC\+\_\+\+USED(x, y))
\item 
\mbox{\Hypertarget{mem_8c_ad9c093807b7be2fac9c6abf956d77b7c}\label{mem_8c_ad9c093807b7be2fac9c6abf956d77b7c}} 
\#define {\bfseries MEM\+\_\+\+SANITY\+\_\+\+OFFSET}~0
\item 
\mbox{\Hypertarget{mem_8c_a862ca44d1acb47ac867d0245f85a1706}\label{mem_8c_a862ca44d1acb47ac867d0245f85a1706}} 
\#define {\bfseries MEM\+\_\+\+SANITY\+\_\+\+OVERHEAD}~0
\item 
\#define \mbox{\hyperlink{mem_8c_a278694c2333c9826f21ddd2c2d220f66}{MIN\+\_\+\+SIZE}}~12
\item 
\mbox{\Hypertarget{mem_8c_a97c704b85f71b6e61b0098b4a0a743cd}\label{mem_8c_a97c704b85f71b6e61b0098b4a0a743cd}} 
\#define {\bfseries MIN\+\_\+\+SIZE\+\_\+\+ALIGNED}~\mbox{\hyperlink{group__compiler__abstraction_gaef204be511fd32f681b55abc08e9ae18}{LWIP\+\_\+\+MEM\+\_\+\+ALIGN\+\_\+\+SIZE}}(\mbox{\hyperlink{mem_8c_a278694c2333c9826f21ddd2c2d220f66}{MIN\+\_\+\+SIZE}})
\item 
\mbox{\Hypertarget{mem_8c_ade9cedd48e9a482120e29c010352ee5c}\label{mem_8c_ade9cedd48e9a482120e29c010352ee5c}} 
\#define {\bfseries SIZEOF\+\_\+\+STRUCT\+\_\+\+MEM}~\mbox{\hyperlink{group__compiler__abstraction_gaef204be511fd32f681b55abc08e9ae18}{LWIP\+\_\+\+MEM\+\_\+\+ALIGN\+\_\+\+SIZE}}(sizeof(struct mem))
\item 
\mbox{\Hypertarget{mem_8c_a78ed2097d5d3e2ca4599b2ca3d91493a}\label{mem_8c_a78ed2097d5d3e2ca4599b2ca3d91493a}} 
\#define {\bfseries MEM\+\_\+\+SIZE\+\_\+\+ALIGNED}~\mbox{\hyperlink{group__compiler__abstraction_gaef204be511fd32f681b55abc08e9ae18}{LWIP\+\_\+\+MEM\+\_\+\+ALIGN\+\_\+\+SIZE}}(MEM\+\_\+\+SIZE)
\item 
\mbox{\Hypertarget{mem_8c_a4fa8ffb4c7a8b4c0404ad4278cc801d0}\label{mem_8c_a4fa8ffb4c7a8b4c0404ad4278cc801d0}} 
\#define {\bfseries LWIP\+\_\+\+RAM\+\_\+\+HEAP\+\_\+\+POINTER}~ram\+\_\+heap
\item 
\mbox{\Hypertarget{mem_8c_a581c4edded02d92caf7a938c801a618e}\label{mem_8c_a581c4edded02d92caf7a938c801a618e}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+FREE\+\_\+\+DECL\+\_\+\+PROTECT}()
\item 
\mbox{\Hypertarget{mem_8c_aef413072690259b59ce27e49df19e307}\label{mem_8c_aef413072690259b59ce27e49df19e307}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+FREE\+\_\+\+PROTECT}()~\mbox{\hyperlink{group__sys__mutex_ga4d4eb9afe5965fa2661dd54ff55d616a}{sys\+\_\+mutex\+\_\+lock}}(\&mem\+\_\+mutex)
\item 
\mbox{\Hypertarget{mem_8c_aa8a24c0593943bb1e64c1243dddfae50}\label{mem_8c_aa8a24c0593943bb1e64c1243dddfae50}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+FREE\+\_\+\+UNPROTECT}()~\mbox{\hyperlink{group__sys__mutex_ga5568f68898fe9d5735f9ce2f665624fb}{sys\+\_\+mutex\+\_\+unlock}}(\&mem\+\_\+mutex)
\item 
\mbox{\Hypertarget{mem_8c_a016a07ea84e1d75386765b90015b6698}\label{mem_8c_a016a07ea84e1d75386765b90015b6698}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+ALLOC\+\_\+\+DECL\+\_\+\+PROTECT}()
\item 
\mbox{\Hypertarget{mem_8c_a3c644ac3ac94ed977bb165eeb6ff741a}\label{mem_8c_a3c644ac3ac94ed977bb165eeb6ff741a}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+ALLOC\+\_\+\+PROTECT}()
\item 
\mbox{\Hypertarget{mem_8c_af0643ce3aa197952517914e1d644150a}\label{mem_8c_af0643ce3aa197952517914e1d644150a}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+ALLOC\+\_\+\+UNPROTECT}()
\item 
\mbox{\Hypertarget{mem_8c_ad74a6d1299af759009028f19154281d3}\label{mem_8c_ad74a6d1299af759009028f19154281d3}} 
\#define {\bfseries LWIP\+\_\+\+MEM\+\_\+\+LFREE\+\_\+\+VOLATILE}
\item 
\mbox{\Hypertarget{mem_8c_a66729ed567ed8f74812d100915d3bd0b}\label{mem_8c_a66729ed567ed8f74812d100915d3bd0b}} 
\#define {\bfseries MEM\+\_\+\+SANITY}()
\item 
\mbox{\Hypertarget{mem_8c_a89d767420435e5edc309c6d32aa6c3eb}\label{mem_8c_a89d767420435e5edc309c6d32aa6c3eb}} 
\#define {\bfseries mem\+\_\+overflow\+\_\+init\+\_\+element}(mem,  size)
\item 
\mbox{\Hypertarget{mem_8c_a3b979ea9bc7806a8e5fb2e94b3be3121}\label{mem_8c_a3b979ea9bc7806a8e5fb2e94b3be3121}} 
\#define {\bfseries mem\+\_\+overflow\+\_\+check\+\_\+element}(mem)
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{mem_8c_a4efff8c25f955c6a771793812bfc0cf4}{LWIP\+\_\+\+DECLARE\+\_\+\+MEMORY\+\_\+\+ALIGNED}} (ram\+\_\+heap, MEM\+\_\+\+SIZE\+\_\+\+ALIGNED+(2U $\ast$SIZEOF\+\_\+\+STRUCT\+\_\+\+MEM))
\item 
void \mbox{\hyperlink{mem_8c_a44a136e3b70c36abb6f8dc060c778113}{mem\+\_\+init}} (void)
\item 
void \mbox{\hyperlink{mem_8c_a65169147c44e9db60d997819af9b455c}{mem\+\_\+free}} (void $\ast$rmem)
\item 
void $\ast$ \mbox{\hyperlink{mem_8c_ab0915b39bd096766771ef4cf719bfb40}{mem\+\_\+trim}} (void $\ast$rmem, mem\+\_\+size\+\_\+t new\+\_\+size)
\item 
void $\ast$ \mbox{\hyperlink{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}{mem\+\_\+malloc}} (mem\+\_\+size\+\_\+t size\+\_\+in)
\item 
void $\ast$ \mbox{\hyperlink{mem_8c_a06b2fb3a6f6a6c56a84f769e0bd4c8e7}{mem\+\_\+calloc}} (mem\+\_\+size\+\_\+t count, mem\+\_\+size\+\_\+t size)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Dynamic memory manager

This is a lightweight replacement for the standard C library malloc().

If you want to use the standard C library malloc() instead, define MEM\+\_\+\+LIBC\+\_\+\+MALLOC to 1 in your \mbox{\hyperlink{lwipopts_8h_source}{lwipopts.\+h}}

To let \mbox{\hyperlink{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}{mem\+\_\+malloc()}} use pools (prevents fragmentation and is much faster than a heap but might waste some memory), define MEM\+\_\+\+USE\+\_\+\+POOLS to 1, define MEMP\+\_\+\+USE\+\_\+\+CUSTOM\+\_\+\+POOLS to 1 and create a file \char`\"{}lwippools.\+h\char`\"{} that includes a list of pools like this (more pools can be added between \+\_\+\+START and \+\_\+\+END)\+:

Define three pools with sizes 256, 512, and 1512 bytes LWIP\+\_\+\+MALLOC\+\_\+\+MEMPOOL\+\_\+\+START LWIP\+\_\+\+MALLOC\+\_\+\+MEMPOOL(20, 256) LWIP\+\_\+\+MALLOC\+\_\+\+MEMPOOL(10, 512) LWIP\+\_\+\+MALLOC\+\_\+\+MEMPOOL(5, 1512) LWIP\+\_\+\+MALLOC\+\_\+\+MEMPOOL\+\_\+\+END 

\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{mem_8c_a278694c2333c9826f21ddd2c2d220f66}\label{mem_8c_a278694c2333c9826f21ddd2c2d220f66}} 
\index{mem.c@{mem.c}!MIN\_SIZE@{MIN\_SIZE}}
\index{MIN\_SIZE@{MIN\_SIZE}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{MIN\_SIZE}{MIN\_SIZE}}
{\footnotesize\ttfamily \#define MIN\+\_\+\+SIZE~12}

All allocated blocks will be MIN\+\_\+\+SIZE bytes big, at least! MIN\+\_\+\+SIZE can be overridden to suit your needs. Smaller values save space, larger values could prevent too small blocks to fragment the RAM too much. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{mem_8c_a4efff8c25f955c6a771793812bfc0cf4}\label{mem_8c_a4efff8c25f955c6a771793812bfc0cf4}} 
\index{mem.c@{mem.c}!LWIP\_DECLARE\_MEMORY\_ALIGNED@{LWIP\_DECLARE\_MEMORY\_ALIGNED}}
\index{LWIP\_DECLARE\_MEMORY\_ALIGNED@{LWIP\_DECLARE\_MEMORY\_ALIGNED}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{LWIP\_DECLARE\_MEMORY\_ALIGNED()}{LWIP\_DECLARE\_MEMORY\_ALIGNED()}}
{\footnotesize\ttfamily LWIP\+\_\+\+DECLARE\+\_\+\+MEMORY\+\_\+\+ALIGNED (\begin{DoxyParamCaption}\item[{ram\+\_\+heap}]{,  }\item[{MEM\+\_\+\+SIZE\+\_\+\+ALIGNED+}]{2\+U $\ast$\+SIZEOF\+\_\+\+STRUCT\+\_\+\+MEM }\end{DoxyParamCaption})}

If you want to relocate the heap to external memory, simply define LWIP\+\_\+\+RAM\+\_\+\+HEAP\+\_\+\+POINTER as a void-\/pointer to that location. If so, make sure the memory at that location is big enough (see below on how that space is calculated). the heap. we need one struct mem at the end and some room for alignment \mbox{\Hypertarget{mem_8c_a06b2fb3a6f6a6c56a84f769e0bd4c8e7}\label{mem_8c_a06b2fb3a6f6a6c56a84f769e0bd4c8e7}} 
\index{mem.c@{mem.c}!mem\_calloc@{mem\_calloc}}
\index{mem\_calloc@{mem\_calloc}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{mem\_calloc()}{mem\_calloc()}}
{\footnotesize\ttfamily void $\ast$ mem\+\_\+calloc (\begin{DoxyParamCaption}\item[{mem\+\_\+size\+\_\+t}]{count,  }\item[{mem\+\_\+size\+\_\+t}]{size }\end{DoxyParamCaption})}

Contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory.

The allocated memory is filled with bytes of value zero.


\begin{DoxyParams}{Parameters}
{\em count} & number of objects to allocate \\
\hline
{\em size} & size of the objects to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to allocated memory / NULL pointer if there is an error 
\end{DoxyReturn}
\mbox{\Hypertarget{mem_8c_a65169147c44e9db60d997819af9b455c}\label{mem_8c_a65169147c44e9db60d997819af9b455c}} 
\index{mem.c@{mem.c}!mem\_free@{mem\_free}}
\index{mem\_free@{mem\_free}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{mem\_free()}{mem\_free()}}
{\footnotesize\ttfamily void mem\+\_\+free (\begin{DoxyParamCaption}\item[{void $\ast$}]{rmem }\end{DoxyParamCaption})}

Put a struct mem back on the heap


\begin{DoxyParams}{Parameters}
{\em rmem} & is the data portion of a struct mem as returned by a previous call to \mbox{\hyperlink{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}{mem\+\_\+malloc()}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{mem_8c_a44a136e3b70c36abb6f8dc060c778113}\label{mem_8c_a44a136e3b70c36abb6f8dc060c778113}} 
\index{mem.c@{mem.c}!mem\_init@{mem\_init}}
\index{mem\_init@{mem\_init}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{mem\_init()}{mem\_init()}}
{\footnotesize\ttfamily void mem\+\_\+init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Zero the heap and initialize start, end and lowest-\/free \mbox{\Hypertarget{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}\label{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}} 
\index{mem.c@{mem.c}!mem\_malloc@{mem\_malloc}}
\index{mem\_malloc@{mem\_malloc}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{mem\_malloc()}{mem\_malloc()}}
{\footnotesize\ttfamily void $\ast$ mem\+\_\+malloc (\begin{DoxyParamCaption}\item[{mem\+\_\+size\+\_\+t}]{size\+\_\+in }\end{DoxyParamCaption})}

Allocate a block of memory with a minimum of \textquotesingle{}size\textquotesingle{} bytes.


\begin{DoxyParams}{Parameters}
{\em size\+\_\+in} & is the minimum size of the requested block in bytes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to allocated memory or NULL if no free memory was found.
\end{DoxyReturn}
Note that the returned value will always be aligned (as defined by MEM\+\_\+\+ALIGNMENT). \mbox{\Hypertarget{mem_8c_ab0915b39bd096766771ef4cf719bfb40}\label{mem_8c_ab0915b39bd096766771ef4cf719bfb40}} 
\index{mem.c@{mem.c}!mem\_trim@{mem\_trim}}
\index{mem\_trim@{mem\_trim}!mem.c@{mem.c}}
\doxysubsubsection{\texorpdfstring{mem\_trim()}{mem\_trim()}}
{\footnotesize\ttfamily void $\ast$ mem\+\_\+trim (\begin{DoxyParamCaption}\item[{void $\ast$}]{rmem,  }\item[{mem\+\_\+size\+\_\+t}]{new\+\_\+size }\end{DoxyParamCaption})}

Shrink memory returned by \mbox{\hyperlink{mem_8c_ae2190f95ae9c46bb99ec0be4f4e4e5e4}{mem\+\_\+malloc()}}.


\begin{DoxyParams}{Parameters}
{\em rmem} & pointer to memory allocated by mem\+\_\+malloc the is to be shrinked \\
\hline
{\em new\+\_\+size} & required size after shrinking (needs to be smaller than or equal to the previous size) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
for compatibility reasons\+: is always == rmem, at the moment or NULL if newsize is \texorpdfstring{$>$}{>} old size, in which case rmem is NOT touched or freed! 
\end{DoxyReturn}
